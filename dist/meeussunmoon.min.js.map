{"version":3,"file":"meeussunmoon.min.js","sources":["../src/auxMath.js","../src/timeConversions.js","../src/moonPhases.js","../src/constants.js","../src/sunTimes.js","../src/index.js"],"sourcesContent":["/**\n * Converts angles in degrees to radians.\n * @param {number} deg Angle in degrees.\n * @returns {number} Angle in radians.\n */\nconst deg2rad = function (deg) {\n  return deg * 0.017453292519943295;\n};\n\n/**\n * Converts angles in radians to degrees.\n * @param {number} rad Angle in radians.\n * @returns {number} Angle in degrees.\n */\nconst rad2deg = function (rad) {\n  return rad * 57.29577951308232;\n};\n\n/**\n * Calculates the sine of an angle given in degrees.\n * @param {number} deg Angle in degrees.\n * @returns {number} Sine of the angle.\n */\nconst sind = function (deg) {\n  return Math.sin(deg2rad(deg));\n};\n\n/**\n * Calculates the cosine of an angle given in degrees.\n * @param {number} deg Angle in degrees.\n * @returns {number} Cosine of the angle.\n */\nconst cosd = function (deg) {\n  return Math.cos(deg2rad(deg));\n};\n\n/**\n * Reduces an angle to the interval 0-360°.\n * @param {number} angle Angle in degrees.\n * @returns {number} Reduced angle in degrees.\n */\nconst reduceAngle = function (angle) {\n  return angle - (360 * Math.floor(angle / 360));\n};\n\n/**\n * Evaluates a polynomial in the form A + Bx + Cx^2...\n * @param {number} variable Value of x in the polynomial.\n * @param {array} coeffs Array of coefficients [A, B, C...].\n * @returns {number} Sum of the polynomial.\n */\nconst polynomial = function (variable, coeffs) {\n  let varPower = 1;\n  let sum = 0.0;\n  const numCoeffs = coeffs.length;\n  for (let i = 0; i < numCoeffs; i++) {\n    sum += varPower * coeffs[i];\n    varPower *= variable;\n  }\n  return sum;\n};\n\n/**\n * Interpolates a value from 3 known values (see AA p24 Eq3.3).\n * @param {number} y1 Start value of the interval.\n * @param {number} y2 Middle value of the interval.\n * @param {number} y3 End value of the interval.\n * @param {number} n Location (-0.5 >= n >= 0.5) of result in the interval.\n * @param {bool} normalize Whether the final result should be normalized.\n * @returns {number} Interpolated result.\n */\nconst interpolateFromThree = function (y1, y2, y3, n, normalize) {\n  let a = y2 - y1;\n  let b = y3 - y2;\n  if (typeof normalize !== 'undefined' && normalize) {\n    if (a < 0) { a += 360; }\n    if (b < 0) { b += 360; }\n  }\n  const c = b - a;\n  const y = y2 + (n / 2) * (a + b + n * c);\n  return y;\n};\n\nexport {deg2rad, rad2deg, sind, cosd, reduceAngle, polynomial,\n  interpolateFromThree};\n","/**\n * Converts a datetime in UTC to the corresponding Julian Date (see AA p60f).\n * @param {moment} datetime Datetime to be converted.\n * @returns {number} Julian date (fractional number of days since 1 January\n *     4713BC according to the proleptic Julian calendar.\n */\nconst datetimeToJD = function (datetime) {\n  let Y = datetime.year();\n  // Months are zero-indexed\n  let M = datetime.month() + 1;\n  const D = datetime.date() + (datetime.hour() + (datetime.minute() +\n                               datetime.second() / 60) / 60) / 24;\n  if (M < 3) {\n    Y -= 1;\n    M += 12;\n  }\n  const A = Math.floor(Y / 100);\n  // Need a different B if we are before introduction of the Gregorian Calendar\n  const gregorianCutoff = moment('1582-10-15T12:00:00Z');\n  let B = 0;\n  if (datetime.isAfter(gregorianCutoff)) {\n    B = 2 - A + Math.floor(A / 4);\n  }\n  const JD = Math.floor(365.25 * (Y + 4716)) +\n             Math.floor(30.6001 * (M + 1)) + D + B - 1524.5;\n  return JD;\n};\n\n/**\n * Converts a Julian Date to the corresponding datetime in UTC (see AA p63).\n * @param {number} JD Julian date to be converted\n * @returns {moment} Datetime corresponding to the given Julian date.\n */\nconst JDToDatetime = function (JD) {\n  JD += 0.5;\n  const Z = Math.floor(JD);\n  const F = JD - Z;\n  let A = Z;\n  if (Z >= 2299161) {\n    const alpha = Math.floor((Z - 1867216.25) / 36524.25);\n    A += 1 + alpha - Math.floor(alpha / 4);\n  }\n  const B = A + 1524;\n  const C = Math.floor((B - 122.1) / 365.25);\n  const D = Math.floor(365.25 * C);\n  const E = Math.floor((B - D) / 30.6001);\n  const fracDay = B - D - Math.floor(30.6001 * E) + F;\n  const day = Math.floor(fracDay);\n  const hours = Math.floor((fracDay - day) * 24);\n  const minutes = Math.floor(((fracDay - day) * 24 - hours) * 60);\n  const seconds =\n    Math.floor((((fracDay - day) * 24 - hours) * 60 - minutes) * 60);\n  let month = E - 1;\n  if (E > 13) {\n    month -= 12;\n  }\n  let year = C - 4715;\n  if (month > 2) {\n    year -= 1;\n  }\n  const datetime = moment.tz('2000-01-01T12:00:00', 'UTC');\n  datetime.year(year);\n  // Months are zero-indexed\n  datetime.month(month - 1);\n  datetime.date(day);\n  datetime.hour(hours);\n  datetime.minute(minutes);\n  datetime.second(seconds);\n  return datetime;\n};\n\n/**\n * Converts a Julian date to the number of Julian centuries since\n * 2000-01-01T12:00:00Z (see AA p87 Eq12.1).\n * @param {number} JD Julian date.\n * @returns {number} T.\n */\nconst JDToT = function (JD) {\n  return (JD - 2451545) / 36525;\n};\n\n/**\n * Converts a datetime in UTC to the number of Julian centuries since\n * 2000-01-01T12:00:00Z.\n * @param {moment} datetime Datetime to be converted.\n * @returns {number} T.\n */\nconst datetimeToT = function (datetime) {\n  return JDToT(datetimeToJD(datetime));\n};\n\n/* eslint-disable complexity */\n/**\n * Calculates the value of ΔT=TT−UT (see\n * http://eclipse.gsfc.nasa.gov/SEcat5/deltatpoly.htm).\n * @param {moment} datetime Datetime for which ΔT should be calculated.\n * @returns {number} ΔT.\n */\nconst DeltaT = function (datetime) {\n  let y = datetime.year();\n  // Months are zero-indexed\n  y += (datetime.month() + 0.5) / 12;\n  let u;\n  let t;\n  let DeltaT;\n  switch (true) {\n    case y < -1999:\n      DeltaT = false;\n      break;\n    case y < -500:\n      u = (y - 1820) / 100;\n      DeltaT = -20 + 32 * u * u;\n      break;\n    case y < 500:\n      u = y / 100;\n      DeltaT = 10583.6 - 1014.41 * u + 33.78311 * u * u - 5.952053 * u * u * u -\n               0.1798452 * u * u * u * u + 0.022174192 * u * u * u * u * u +\n               0.0090316521 * u * u * u * u * u * u;\n      break;\n    case y < 1600:\n      u = (y - 1000) / 100;\n      DeltaT = 1574.2 - 556.01 * u + 71.23472 * u * u + 0.319781 * u * u * u -\n               0.8503463 * u * u * u * u - 0.005050998 * u * u * u * u * u +\n               0.0083572073 * u * u * u * u * u * u;\n      break;\n    case y < 1700:\n      t = y - 1600;\n      DeltaT = 120 - 0.9808 * t - 0.01532 * t * t + t * t * t / 7129;\n      break;\n    case y < 1800:\n      t = y - 1700;\n      DeltaT = 8.83 + 0.1603 * t - 0.0059285 * t * t + 0.00013336 * t * t * t -\n               t * t * t * t / 1174000;\n      break;\n    case y < 1860:\n      t = y - 1800;\n      DeltaT = 13.72 - 0.332447 * t + 0.0068612 * t * t +\n               0.0041116 * t * t * t - 0.00037436 * t * t * t * t +\n               0.0000121272 * t * t * t * t * t -\n               0.0000001699 * t * t * t * t * t * t +\n               0.000000000875 * t * t * t * t * t * t * t;\n      break;\n    case y < 1900:\n      t = y - 1860;\n      DeltaT = 7.62 + 0.5737 * t - 0.251754 * t * t + 0.01680668 * t * t * t -\n               0.0004473624 * t * t * t * t + t * t * t * t * t / 233174;\n      break;\n    case y < 1920:\n      t = y - 1900;\n      DeltaT = -2.79 + 1.494119 * t - 0.0598939 * t * t +\n                0.0061966 * t * t * t - 0.000197 * t * t * t * t;\n      break;\n    case y < 1941:\n      t = y - 1920;\n      DeltaT = 21.20 + 0.84493 * t - 0.076100 * t * t + 0.0020936 * t * t * t;\n      break;\n    case y < 1961:\n      t = y - 1950;\n      DeltaT = 29.07 + 0.407 * t - t * t / 233 + t * t * t / 2547;\n      break;\n    case y < 1986:\n      t = y - 1975;\n      DeltaT = 45.45 + 1.067 * t - t * t / 260 - t * t * t / 718;\n      break;\n    case y < 2005:\n      t = y - 2000;\n      DeltaT = 63.86 + 0.3345 * t - 0.060374 * t * t + 0.0017275 * t * t * t +\n               0.000651814 * t * t * t * t + 0.00002373599 * t * t * t * t * t;\n      break;\n    case y < 2050:\n      t = y - 2000;\n      DeltaT = 62.92 + 0.32217 * t + 0.005589 * t * t;\n      break;\n    case y < 2150:\n      DeltaT = -20 + 32 * ((y - 1820) / 100) * ((y - 1820) / 100) -\n        0.5628 * (2150 - y);\n      break;\n    default:\n      u = (y - 1820) / 100;\n      DeltaT = -20 + 32 * u * u;\n  }\n  return DeltaT;\n};\n/* eslint-enable complexity */\n\n/**\n * Calculates an approximate value for k (the fractional number of new moons\n * since 2000-01-06).\n * @param {moment} datetime Datetime for which k is calculated.\n * @returns {number} k.\n */\nconst approxK = function (datetime) {\n  const year = datetime.year() + (datetime.month() + 1) / 12 +\n    datetime.date() / 365.25;\n  return (year - 2000) * 12.3685;\n};\n\n/**\n * Calculates T from k.\n * @param {number} k Fractional number of new moons since 2000-01-06.\n * @returns {number} T Fractional num. of centuries since 2000-01-01:12:00:00Z.\n */\nconst kToT = function (k) {\n  return k / 1236.85;\n};\n\nexport {datetimeToJD, JDToDatetime, JDToT, datetimeToT, DeltaT, approxK, kToT};\n","import * as auxMath from './auxMath.js';\nimport * as timeConversions from './timeConversions.js';\n\n/**\n * Calculates the Julian date in ephemeris time of the moon near the date\n * corresponding to k (see AA p350ff).\n * @param {number} k The approximate fractional number of new moons since\n *     2000-01-06.\n * @param {int} phase 0 -> new moon, 1 -> first quarter,\n *                    2 -> full moon, 3 -> last quarter.\n * @returns {number} Julian date in ephemeris time of the moon of given phase.\n */\nconst truePhase = function (k, phase) {\n  k += phase / 4;\n  const T = timeConversions.kToT(k);\n  const E = eccentricityCorrection(T);\n  let JDE = meanPhase(T, k);\n  const M = sunMeanAnomaly(T, k);\n  const MPrime = moonMeanAnomaly(T, k);\n  const F = moonArgumentOfLatitude(T, k);\n  const Omega = moonAscendingNodeLongitude(T, k);\n  const A = planetaryArguments(T, k);\n  let DeltaJDE = 0;\n  if (phase === 0 || phase === 2) {\n    DeltaJDE += newMoonFullMoonCorrections(E, M, MPrime, F, Omega, phase);\n  } else if (phase === 1 || phase === 3) {\n    DeltaJDE += quarterCorrections(E, M, MPrime, F, Omega, phase);\n  }\n  DeltaJDE += commonCorrections(A);\n  JDE += DeltaJDE;\n  return JDE;\n};\n\n/**\n * Calculates the mean phase of the moon as Julian date in ephemeris time (see\n * AA p349 Eq49.1).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @param {number} k The approximate fractional number of new moons since\n *     2000-01-06.\n * @returns {number} Julian date in ephemeris time of the moon of given mean\n *     phase.\n */\nconst meanPhase = function (T, k) {\n  const JDE = 2451550.09766 + 29.530588861 * k + 0.00015437 * T * T -\n              0.000000150 * T * T * T + 0.00000000073 * T * T * T * T;\n  return JDE;\n};\n\n/**\n * Calculates the mean anomaly of the sun (see AA p350 Eq49.4).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @param {number} k The approximate fractional number of new moons since\n *     2000-01-06.\n * @returns {number} Mean anomaly of the sun at the given time.\n */\nconst sunMeanAnomaly = function (T, k) {\n  const M = 2.5534 + 29.10535670 * k - 0.0000014 * T * T -\n            0.00000011 * T * T * T;\n  return M;\n};\n\n/**\n * Calculates the mean anomaly of the moon (see AA p350 Eq49.5).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @param {number} k The approximate fractional number of new moons since\n *     2000-01-06.\n * @returns {number} Mean anomaly of the moon at the given time.\n */\nconst moonMeanAnomaly = function (T, k) {\n  const MPrime = 201.5643 + 385.81693528 * k + 0.0107582 * T * T +\n                 0.00001238 * T * T * T - 0.000000058 * T * T * T * T;\n  return MPrime;\n};\n\n/**\n * Calculates the argument of latitude of the moon (see AA p350 Eq49.6).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @param {number} k The approximate fractional number of new moons since\n *     2000-01-06.\n * @returns {number} Argument of latitude of the moon at the given time.\n */\nconst moonArgumentOfLatitude = function (T, k) {\n  const F = 160.7108 + 390.67050284 * k - 0.0016118 * T * T -\n            0.00000227 * T * T * T + 0.000000011 * T * T * T * T;\n  return F;\n};\n\n/**\n * Calculates the longitude of the ascending node of the lunar orbit (see AA\n * p350 Eq49.7).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @param {number} k The approximate fractional number of new moons since\n *     2000-01-06.\n * @returns {number} Longitude of the ascending node of the lunar orbit at the\n *     given time.\n */\nconst moonAscendingNodeLongitude = function (T, k) {\n  const Omega = 124.7746 - 1.56375588 * k + 0.0020672 * T * T +\n                0.00000215 * T * T * T;\n  return Omega;\n};\n\n/**\n * Calculates the correction for the eccentricity of the earth's orbit.\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Eccentricity correction.\n */\nconst eccentricityCorrection = function (T) {\n  const E = 1 - 0.002516 * T - 0.0000074 * T * T;\n  return E;\n};\n\n/**\n * Calculates the planetary arguments for the moon phases (see AA p351).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @param {number} k The approximate fractional number of new moons since\n *     2000-01-06.\n * @returns {array} Planetary arguments for the moon phases.\n */\nconst planetaryArguments = function (T, k) {\n  const A = [];\n  /* eslint-disable no-multi-spaces */\n  // Want to follow the numbering conventions from AA\n  A[0]  = 0;\n  A[1]  = 299.77 +  0.107408 * k - 0.009173 * T * T;\n  A[2]  = 251.88 +  0.016321 * k;\n  A[3]  = 251.83 + 26.651886 * k;\n  A[4]  = 349.42 + 36.412478 * k;\n  A[5]  =  84.66 + 18.206239 * k;\n  A[6]  = 141.74 + 53.303771 * k;\n  A[7]  = 207.14 +  2.453732 * k;\n  A[8]  = 154.84 +  7.306860 * k;\n  A[9]  =  34.52 + 27.261239 * k;\n  A[10] = 207.19 +  0.121824 * k;\n  A[11] = 291.34 +  1.844379 * k;\n  A[12] = 161.72 + 24.198154 * k;\n  A[13] = 239.56 + 25.513099 * k;\n  A[14] = 331.55 +  3.592518 * k;\n  /* eslint-enable no-multi-spaces */\n  return A;\n};\n\n/**\n * Calculates the corrections to the planetary arguments for the moon phases\n * that are common to all phases (see AA p352).\n * @param {array} A Array of planetary arguments\n * @returns {number} Correction to the Julian date in ephemeris time for the\n *     moon phase.\n */\nconst commonCorrections = function (A) {\n  const DeltaJDE = 0.000325 * auxMath.sind(A[1]) +\n                   0.000165 * auxMath.sind(A[2]) +\n                   0.000164 * auxMath.sind(A[3]) +\n                   0.000126 * auxMath.sind(A[4]) +\n                   0.000110 * auxMath.sind(A[5]) +\n                   0.000062 * auxMath.sind(A[6]) +\n                   0.000060 * auxMath.sind(A[7]) +\n                   0.000056 * auxMath.sind(A[8]) +\n                   0.000047 * auxMath.sind(A[9]) +\n                   0.000042 * auxMath.sind(A[10]) +\n                   0.000040 * auxMath.sind(A[11]) +\n                   0.000037 * auxMath.sind(A[12]) +\n                   0.000035 * auxMath.sind(A[13]) +\n                   0.000023 * auxMath.sind(A[14]);\n  return DeltaJDE;\n};\n\n/**\n * Calculates the corrections to the planetary arguments for the moon phases\n * for full and new moons (see AA p351).\n * @param {number} E Correction for the eccentricity of the earth's orbit.\n * @param {number} M Mean anomaly of the sun.\n * @param {number} MPrime Mean anomaly of the moon.\n * @param {number} F Argument of latitude of the moon.\n * @param {number} Omega Longitude of the ascending node of the lunar orbit.\n * @param {int} phase 0 -> new moon, 1 -> first quarter,\n *                    2 -> full moon, 3 -> last quarter.\n * @returns {number} Correction to the Julian date in ephemeris time for the\n *     moon phase.\n */\nconst newMoonFullMoonCorrections = function (E, M, MPrime, F, Omega, phase) {\n  let DeltaJDE = -0.00111 * auxMath.sind(MPrime - 2 * F) -\n                  0.00057 * auxMath.sind(MPrime + 2 * F) +\n                  0.00056 * E * auxMath.sind(2 * MPrime + M) -\n                  0.00042 * auxMath.sind(3 * MPrime) +\n                  0.00042 * E * auxMath.sind(M + 2 * F) +\n                  0.00038 * E * auxMath.sind(M - 2 * F) -\n                  0.00024 * E * auxMath.sind(2 * MPrime - M) -\n                  0.00017 * auxMath.sind(Omega) -\n                  0.00007 * auxMath.sind(MPrime + 2 * M) +\n                  0.00004 * auxMath.sind(2 * MPrime - 2 * F) +\n                  0.00004 * auxMath.sind(3 * M) +\n                  0.00003 * auxMath.sind(MPrime + M - 2 * F) +\n                  0.00003 * auxMath.sind(2 * MPrime + 2 * F) -\n                  0.00003 * auxMath.sind(MPrime + M + 2 * F) +\n                  0.00003 * auxMath.sind(MPrime - M + 2 * F) -\n                  0.00002 * auxMath.sind(MPrime - M - 2 * F) -\n                  0.00002 * auxMath.sind(3 * MPrime + M) +\n                  0.00002 * auxMath.sind(4 * MPrime);\n  if (phase === 0) {\n    DeltaJDE += -0.40720 * auxMath.sind(MPrime) +\n                 0.17241 * E * auxMath.sind(M) +\n                 0.01608 * auxMath.sind(2 * MPrime) +\n                 0.01039 * auxMath.sind(2 * F) +\n                 0.00739 * E * auxMath.sind(MPrime - M) -\n                 0.00514 * E * auxMath.sind(MPrime + M) +\n                 0.00208 * E * E * auxMath.sind(2 * M);\n  } else if (phase === 2) {\n    DeltaJDE += -0.40614 * auxMath.sind(MPrime) +\n                 0.17302 * E * auxMath.sind(M) +\n                 0.01614 * auxMath.sind(2 * MPrime) +\n                 0.01043 * auxMath.sind(2 * F) +\n                 0.00734 * E * auxMath.sind(MPrime - M) -\n                 0.00515 * E * auxMath.sind(MPrime + M) +\n                 0.00209 * E * E * auxMath.sind(2 * M);\n  }\n  return DeltaJDE;\n};\n\n/**\n * Calculates the corrections to the planetary arguments for the moon phases\n * for first and last quarters (see AA p352).\n * @param {number} E Correction for the eccentricity of the earth's orbit.\n * @param {number} M Mean anomaly of the sun.\n * @param {number} MPrime Mean anomaly of the moon.\n * @param {number} F Argument of latitude of the moon.\n * @param {number} Omega Longitude of the ascending node of the lunar orbit.\n * @param {int} phase 0 -> new moon, 1 -> first quarter,\n *                    2 -> full moon, 3 -> last quarter.\n * @returns {number} Correction to the Julian date in ephemeris time for the\n *     moon phase.\n */\nconst quarterCorrections = function (E, M, MPrime, F, Omega, phase) {\n  let DeltaJDE = -0.62801 * auxMath.sind(MPrime) +\n                  0.17172 * E * auxMath.sind(M) -\n                  0.01183 * E * auxMath.sind(MPrime + M) +\n                  0.00862 * auxMath.sind(2 * MPrime) +\n                  0.00804 * auxMath.sind(2 * F) +\n                  0.00454 * E * auxMath.sind(MPrime - M) +\n                  0.00204 * E * E * auxMath.sind(2 * M) -\n                  0.00180 * auxMath.sind(MPrime - 2 * F) -\n                  0.00070 * auxMath.sind(MPrime + 2 * F) -\n                  0.00040 * auxMath.sind(3 * MPrime) -\n                  0.00034 * E * auxMath.sind(2 * MPrime - M) +\n                  0.00032 * E * auxMath.sind(M + 2 * F) +\n                  0.00032 * E * auxMath.sind(M - 2 * F) -\n                  0.00028 * E * E * auxMath.sind(MPrime + 2 * M) +\n                  0.00027 * E * auxMath.sind(2 * MPrime + M) -\n                  0.00017 * auxMath.sind(Omega) -\n                  0.00005 * auxMath.sind(MPrime - M - 2 * F) +\n                  0.00004 * auxMath.sind(2 * MPrime + 2 * F) -\n                  0.00004 * auxMath.sind(MPrime + M + 2 * F) +\n                  0.00004 * auxMath.sind(MPrime - 2 * M) +\n                  0.00003 * auxMath.sind(MPrime + M - 2 * F) +\n                  0.00003 * auxMath.sind(3 * M) +\n                  0.00002 * auxMath.sind(2 * MPrime - 2 * F) +\n                  0.00002 * auxMath.sind(MPrime - M + 2 * F) -\n                  0.00002 * auxMath.sind(3 * MPrime + M);\n  const W = 0.00306 -\n            0.00038 * E * auxMath.cosd(M) +\n            0.00026 * auxMath.cosd(MPrime) -\n            0.00002 * auxMath.cosd(MPrime - M) +\n            0.00002 * auxMath.cosd(MPrime + M) +\n            0.00002 * auxMath.cosd(2 * F);\n  if (phase === 1) {\n    DeltaJDE += W;\n  } else if (phase === 3) {\n    DeltaJDE -= W;\n  }\n  return DeltaJDE;\n};\n\nexport {truePhase};\n","/* eslint array-bracket-spacing: \"off\", indent: \"off\", no-multi-spaces: \"off\", standard/array-bracket-even-spacing: \"off\" */\n\n/** See AA p144 */\nconst sunMeanAnomaly = [357.52772, 35999.050340, -0.0001603, -1 / 300000];\n\n/** See AA p163 Eq 25.2 */\nconst sunMeanLongitude = [280.46646, 36000.76983, 0.0003032];\n\n/** See AA p147 Eq22.3 */\nconst meanObliquityOfEcliptic =\n  [84381.448 / 3600, -4680.93 / 3600, -1.55 / 3600, 1999.25 / 3600,\n   -51.38 / 3600, -249.67 / 3600, -39.05 / 3600, 7.12 / 3600, 27.87 / 3600,\n   5.79 / 3600, 2.45 / 3600];\n\n/** See AA p144 */\nconst moonArgumentOfLatitude =\n  [93.27191, 483202.017538, -0.0036825, 1 / 327270];\n\n/** See AA p144 */\nconst moonAscendingNodeLongitude =\n  [125.04452, -1934.136261, 0.0020708, 1 / 450000];\n\n/** See AA p144 */\nconst moonMeanAnomaly = [134.96298, 477198.867398, 0.0086972, 1 / 56250];\n\n/** See AA p144 */\nconst moonMeanElongation = [297.85036, 445267.111480, -0.0019142, 1 / 189474];\n\n/**\n * Nutations in longitude and obliquity\n * See AA p145f\n */\nconst nutations =\n  [[ 0,  0,  0,  0, 1, -171996, -174.2, 92025,  8.9],\n   [-2,  0,  0,  2, 2,  -13187,   -1.6,  5736, -3.1],\n   [ 0,  0,  0,  2, 2,   -2274,   -0.2,   977, -0.5],\n   [ 0,  0,  0,  0, 2,    2062,    0.2,  -895,  0.5],\n   [ 0,  1,  0,  0, 0,    1426,   -3.4,    54, -0.1],\n   [ 0,  0,  1,  0, 0,     712,    0.1,    -7,    0],\n   [-2,  1,  0,  2, 2,    -517,    1.2,   224, -0.6],\n   [ 0,  0,  0,  2, 1,    -386,   -0.4,   200,    0],\n   [ 0,  0,  1,  2, 2,    -301,      0,   129, -0.1],\n   [-2, -1,  0,  2, 2,     217,   -0.5,   -95,  0.3],\n   [-2,  0,  1,  0, 0,    -158,      0,     0,    0],\n   [-2,  0,  0,  2, 1,     129,    0.1,   -70,    0],\n   [ 0,  0, -1,  2, 2,     123,      0,   -53,    0],\n   [ 2,  0,  0,  0, 0,      63,      0,     0,    0],\n   [ 0,  0,  1,  0, 1,      63,    0.1,   -33,    0],\n   [ 2,  0, -1,  2, 2,     -59,      0,    26,    0],\n   [ 0,  0, -1,  0, 1,     -58,   -0.1,    32,    0],\n   [ 0,  0,  1,  2, 1,     -51,      0,    27,    0],\n   [-2,  0,  2,  0, 0,      48,      0,     0,    0],\n   [ 0,  0, -2,  2, 1,      46,      0,   -24,    0],\n   [ 2,  0,  0,  2, 2,     -38,      0,    16,    0],\n   [ 0,  0,  2,  2, 2,     -31,      0,    13,    0],\n   [ 0,  0,  2,  0, 0,      29,      0,     0,    0],\n   [-2,  0,  1,  2, 2,      29,      0,   -12,    0],\n   [ 0,  0,  0,  2, 0,      26,      0,     0,    0],\n   [-2,  0,  0,  2, 0,     -22,      0,     0,    0],\n   [ 0,  0, -1,  2, 1,      21,      0,   -10,    0],\n   [ 0,  2,  0,  0, 0,      17,   -0.1,     0,    0],\n   [ 2,  0, -1,  0, 1,      16,      0,    -8,    0],\n   [-2,  2,  0,  2, 2,     -16,    0.1,     7,    0],\n   [ 0,  1,  0,  0, 1,     -15,      0,     9,    0],\n   [-2,  0,  1,  0, 1,     -13,      0,     7,    0],\n   [ 0, -1,  0,  0, 1,     -12,      0,     6,    0],\n   [ 0,  0,  2, -2, 0,      11,      0,     0,    0],\n   [ 2,  0, -1,  2, 1,     -10,      0,     5,    0],\n   [ 2,  0,  1,  2, 2,     -8,       0,     3,    0],\n   [ 0,  1,  0,  2, 2,      7,       0,    -3,    0],\n   [-2,  1,  1,  0, 0,     -7,       0,     0,    0],\n   [ 0, -1,  0,  2, 2,     -7,       0,     3,    0],\n   [ 2,  0,  0,  2, 1,     -7,       0,     3,    0],\n   [ 2,  0,  1,  0, 0,      6,       0,     0,    0],\n   [-2,  0,  2,  2, 2,      6,       0,    -3,    0],\n   [-2,  0,  1,  2, 1,      6,       0,    -3,    0],\n   [ 2,  0, -2,  0, 1,     -6,       0,     3,    0],\n   [ 2,  0,  0,  0, 1,     -6,       0,     3,    0],\n   [ 0, -1,  1,  0, 0,      5,       0,     0,    0],\n   [-2, -1,  0,  2, 1,     -5,       0,     3,    0],\n   [-2,  0,  0,  0, 1,     -5,       0,     3,    0],\n   [ 0,  0,  2,  2, 1,     -5,       0,     3,    0],\n   [-2,  0,  2,  0, 1,      4,       0,     0,    0],\n   [-2,  1,  0,  2, 1,      4,       0,     0,    0],\n   [ 0,  0,  1, -2, 0,      4,       0,     0,    0],\n   [-1,  0,  1,  0, 0,     -4,       0,     0,    0],\n   [-2,  1,  0,  0, 0,     -4,       0,     0,    0],\n   [ 1,  0,  0,  0, 0,     -4,       0,     0,    0],\n   [ 0,  0,  1,  2, 0,      3,       0,     0,    0],\n   [ 0,  0, -2,  2, 2,     -3,       0,     0,    0],\n   [-1, -1,  1,  0, 0,     -3,       0,     0,    0],\n   [ 0,  1,  1,  0, 0,     -3,       0,     0,    0],\n   [ 0, -1,  1,  2, 2,     -3,       0,     0,    0],\n   [ 2, -1, -1,  2, 2,     -3,       0,     0,    0],\n   [ 0,  0,  3,  2, 2,      3,       0,     0,    0],\n   [ 2, -1,  0,  2, 2,     -3,       0,     0,    0]];\n\nexport {sunMeanAnomaly, sunMeanLongitude, meanObliquityOfEcliptic,\n  moonArgumentOfLatitude, moonAscendingNodeLongitude, moonMeanAnomaly,\n  moonMeanElongation, nutations};\n","import * as auxMath from './auxMath.js';\nimport * as constants from './constants.js';\nimport * as timeConversions from './timeConversions.js';\nimport {returnTimeForPNMS, roundToNearestMinute} from './index.js';\n\n/**\n * Calculates the solar transit time on a date at a given longitude (see AA\n * p102f).\n * @param {moment} datetime Date for which transit is calculated.\n * @param {number} L Longitude.\n * @returns {moment} Solar transit time.\n */\nconst sunTransit = function (datetime, L) {\n  const timezone = datetime.tz();\n  const transit = moment.tz(\n    [datetime.year(), datetime.month(), datetime.date(), 0, 0, 0], 'UTC');\n  const DeltaT = timeConversions.DeltaT(transit);\n  const T = timeConversions.datetimeToT(transit);\n  const Theta0 = apparentSiderealTimeGreenwhich(T);\n  // Want 0h TD for this, not UT\n  const TD = T - (DeltaT / (3600 * 24 * 36525));\n  const alpha = sunApparentRightAscension(TD);\n  // Sign flip for longitude from AA as we take East as positive\n  let m = (alpha - L - Theta0) / 360;\n  m = normalizeM(m, datetime.utcOffset());\n  const DeltaM = sunTransitCorrection(T, Theta0, DeltaT, L, m);\n  m += DeltaM;\n  transit.add(Math.floor(m * 3600 * 24 + 0.5), 'seconds');\n  if (roundToNearestMinute) {\n    transit.add(30, 'seconds');\n    transit.second(0);\n  }\n  transit.tz(timezone);\n  return transit;\n};\n\n/**\n * Calculates the sunrise or sunset time on a date at a given latitude and\n * longitude (see AA p102f).\n * @param {moment} datetime Date for which sunrise or sunset is calculated.\n * @param {number} phi Latitude.\n * @param {number} L Longitude.\n * @param {string} flag 'RISE' or 'SET' depending on which event should be\n *     calculated.\n * @param {number} offset number of degrees below the horizon for the desired\n *     event (50/60 for sunrise/set, 6 for civil, 12 for nautical, 18 for\n *     astronomical dawn/dusk.\n * @returns {moment} Sunrise or sunset time.\n */\nconst sunRiseSet = function (datetime, phi, L, flag, offset = 50 / 60) {\n  const timezone = datetime.tz();\n  const suntime = moment.tz(\n    [datetime.year(), datetime.month(), datetime.date(), 0, 0, 0], 'UTC');\n  const DeltaT = timeConversions.DeltaT(suntime);\n  const T = timeConversions.datetimeToT(suntime);\n  const Theta0 = apparentSiderealTimeGreenwhich(T);\n  // Want 0h TD for this, not UT\n  const TD = T - (DeltaT / (3600 * 24 * 36525));\n  const alpha = sunApparentRightAscension(TD);\n  const delta = sunApparentDeclination(TD);\n  const H0 = approxLocalHourAngle(phi, delta, offset);\n  // Sign flip for longitude from AA as we take East as positive\n  let m0 = (alpha - L - Theta0) / 360;\n  m0 = normalizeM(m0, datetime.utcOffset());\n  let m;\n  if (flag === 'RISE') {\n    m = m0 - H0 / 360;\n  } else if (flag === 'SET') {\n    m = m0 + H0 / 360;\n  } else {\n    return false;\n  }\n  let counter = 0;\n  let DeltaM = 1;\n  // Repeat if correction is larger than ~9s\n  while ((Math.abs(DeltaM) > 0.0001) && (counter < 3)) {\n    DeltaM = sunRiseSetCorrection(T, Theta0, DeltaT, phi, L, m, offset);\n    m += DeltaM;\n    counter++;\n  }\n  if (m > 0) {\n    suntime.add(Math.floor(m * 3600 * 24 + 0.5), 'seconds');\n  } else {\n    suntime.subtract(Math.floor(Math.abs(m) * 3600 * 24 + 0.5), 'seconds');\n  }\n  if (roundToNearestMinute) {\n    suntime.add(30, 'seconds');\n    suntime.second(0);\n  }\n  suntime.tz(timezone);\n  return suntime;\n};\n\n/**\n * Returns 06:00/18:00 (07:00/19:00 during DST) if there is no sunrise or sunset\n * on the date. If returnTimeForPNMS is true, otherwise return whether there is\n * Polar Night or Midnight Sun.\n * @param {moment} returnDate The calculated time for sunrise or sunset.\n * @param {moment} date The original date from which the event was calculated.\n * @param {int} hour Hour to which the returned datetime should be set.\n * @param {int} minute Minute to which the returned datetime should be set.\n * @returns {(moment|string)} Time given by parameter 'hour' (+ correction for\n *     DST if applicable) or a string indicating that the location experiences\n *     midnight sun ('MS') or polar night ('PN') on that date.\n */\nconst returnPNMS = function (returnDate, date, hour, minute = 0) {\n  if (returnTimeForPNMS) {\n    if (date.isDST()) {\n      hour += 1;\n    }\n    returnDate.tz(date.tz())\n      .year(date.year())\n      .month(date.month())\n      .date(date.date())\n      .hour(hour)\n      .minute(minute)\n      .second(0);\n  }\n  return returnDate;\n};\n\n/**\n * Calculates the approximate local hour angle of the sun at sunrise or sunset.\n * @param {number} phi Latitude (see AA p102 Eq15.1).\n * @param {number} delta Apparent declination of the sun.\n * @param {number} offset number of degrees below the horizon for the desired\n *     event (50/60 for sunrise/set, 6 for civil, 12 for nautical, 18 for\n *     astronomical dawn/dusk.\n * @returns {number} Approximate local hour angle.\n */\nconst approxLocalHourAngle = function (phi, delta, offset) {\n  const cosH0 = (auxMath.sind(-offset) -\n                auxMath.sind(phi) * auxMath.sind(delta)) /\n                (auxMath.cosd(phi) * auxMath.cosd(delta));\n  if (cosH0 < -1) {\n    if (returnTimeForPNMS) {\n      throw moment.tz('**2000-01-01 12:00:00', 'YYYY-MM-DD HH:mm:ss',\n        'Europe/London');\n    } else {\n      let special = 'MS';\n      if (offset === 6) {\n        special = 'NCD';\n      } else if (offset === 12) {\n        special = 'NND';\n      } else if (offset === 18) {\n        special = 'NAD';\n      }\n      throw special;\n    }\n  } else if (cosH0 > 1) {\n    if (returnTimeForPNMS) {\n      throw moment.tz('--2000-01-01 12:00:00', 'YYYY-MM-DD HH:mm:ss',\n        'Europe/London');\n    } else {\n      let special = 'PN';\n      if (offset === 6) {\n        special = 'NCD';\n      } else if (offset === 12) {\n        special = 'NND';\n      } else if (offset === 18) {\n        special = 'NAD';\n      }\n      throw special;\n    }\n  }\n  const H0 = auxMath.rad2deg(Math.acos(cosH0));\n  return H0;\n};\n\n/**\n * Normalizes a fractional time of day to be on the correct date.\n * @param {number} m Fractional time of day\n * @param {int} utcOffset Offset in minutes from UTC.\n * @returns {number} m Normalized m.\n */\nconst normalizeM = function (m, utcOffset) {\n  const localM = m + utcOffset / 1440;\n  if (localM < 0) {\n    return m + 1;\n  } else if (localM > 1) {\n    return m - 1;\n  }\n  return m;\n};\n\n/**\n * Calculates the correction for the solar transit time (see AA p103).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @param {number} Theta0 Apparent sidereal time at Greenwhich.\n * @param {number} DeltaT ΔT = TT − UT.\n * @param {number} L Longitude.\n * @param {number} m Fractional time of day of the event.\n * @returns {number} Currection for the solar transit time.\n */\nconst sunTransitCorrection = function (T, Theta0, DeltaT, L, m) {\n  const theta0 = Theta0 + 360.985647 * m;\n  const n = m + DeltaT / 864000;\n  const alpha = interpolatedRa(T, n);\n  const H = localHourAngle(theta0, L, alpha);\n  const DeltaM = -H / 360;\n  return DeltaM;\n};\n\n/**\n * Calculates the correction for the sunrise/sunset time (see AA p103).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @param {number} Theta0 Apparent sidereal time at Greenwhich.\n * @param {number} DeltaT ΔT = TT − UT.\n * @param {number} phi Latitude.\n * @param {number} L Longitude.\n * @param {number} m Fractional time of day of the event.\n * @param {number} offset number of degrees below the horizon for the desired\n *     event (50/60 for sunrise/set, 6 for civil, 12 for nautical, 18 for\n *     astronomical dawn/dusk.\n * @returns {number} Currection for the sunrise/sunset time.\n */\nconst sunRiseSetCorrection = function (T, Theta0, DeltaT, phi, L, m, offset) {\n  const theta0 = Theta0 + 360.985647 * m;\n  const n = m + DeltaT / 864000;\n  const alpha = interpolatedRa(T, n);\n  const delta = interpolatedDec(T, n);\n  const H = localHourAngle(theta0, L, alpha);\n  const h = altitude(phi, delta, H);\n  const DeltaM = (h + offset) /\n    (360 * auxMath.cosd(delta) * auxMath.cosd(phi) * auxMath.sind(H));\n  return DeltaM;\n};\n\n/**\n * Calculates the local hour angle of the sun (see AA p103).\n * @param {number} theta0 Sidereal time at Greenwhich in degrees.\n * @param {number} L Longitude.\n * @param {number} alpha Apparent right ascension of the sun.\n * @returns {number} Local hour angle of the sun.\n */\nconst localHourAngle = function (theta0, L, alpha) {\n  // Signflip for longitude\n  let H = auxMath.reduceAngle(theta0 + L - alpha);\n  if (H > 180) { H -= 360; }\n  return H;\n};\n\n/**\n * Calculates the altitude of the sun above the horizon (see AA P93 Eq13.6).\n * @param {number} phi Latitude.\n * @param {number} delta Apparent declination of the sun.\n * @param {number} H Local hour angle of the sun.\n * @returns {number} Altitude of the sun above the horizon.\n */\nconst altitude = function (phi, delta, H) {\n  const h = auxMath.rad2deg(Math.asin(\n    auxMath.sind(phi) * auxMath.sind(delta) +\n    auxMath.cosd(phi) * auxMath.cosd(delta) * auxMath.cosd(H)));\n  return h;\n};\n\n/**\n * Interpolates the sun's right ascension (see AA p103).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @param {number} n Fractional time of day of the event corrected by ΔT.\n * @returns {number} Interpolated right ascension.\n */\nconst interpolatedRa = function (T, n) {\n  const alpha1 = sunApparentRightAscension(T - (1 / 36525));\n  const alpha2 = sunApparentRightAscension(T);\n  const alpha3 = sunApparentRightAscension(T + (1 / 36525));\n  // I don't understand why the RA has to be interpolated with normalization\n  // but the Dec without, but the returned values are wrong otherwise...\n  const alpha = auxMath.interpolateFromThree(alpha1, alpha2, alpha3, n, true);\n  return auxMath.reduceAngle(alpha);\n};\n\n/**\n * Interpolates the sun's declination (see AA p103).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @param {number} n Fractional time of day of the event corrected by ΔT.\n * @returns {number} Interpolated declination.\n */\nconst interpolatedDec = function (T, n) {\n  const delta1 = sunApparentDeclination(T - (1 / 36525));\n  const delta2 = sunApparentDeclination(T);\n  const delta3 = sunApparentDeclination(T + (1 / 36525));\n  const delta = auxMath.interpolateFromThree(delta1, delta2, delta3, n);\n  return auxMath.reduceAngle(delta);\n};\n\n/**\n * Calculates the apparent right ascension of the sun (see AA p165 Eq25.6).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Apparent right ascension of the sun.\n */\nconst sunApparentRightAscension = function (T) {\n  const Omega = moonAscendingNodeLongitude(T);\n  const epsilon = trueObliquityOfEcliptic(T) +\n                  0.00256 * auxMath.cosd(Omega);\n  const lambda = sunApparentLongitude(T);\n  const alpha = auxMath.rad2deg(Math.atan2(\n    auxMath.cosd(epsilon) * auxMath.sind(lambda), auxMath.cosd(lambda)));\n  return auxMath.reduceAngle(alpha);\n};\n\n/**\n * Calculates the apparent declination of the sun (see AA p165 Eq25.7).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Apparent declination of the sun.\n */\nconst sunApparentDeclination = function (T) {\n  const Omega = moonAscendingNodeLongitude(T);\n  const epsilon = trueObliquityOfEcliptic(T) +\n                  0.00256 * auxMath.cosd(Omega);\n  const lambda = sunApparentLongitude(T);\n  const delta = auxMath.rad2deg(Math.asin(\n    auxMath.sind(epsilon) * auxMath.sind(lambda)));\n  return delta;\n};\n\n/**\n * Calculates the apparent sidereal time at Greenwhich (see AA p88).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Apparent sidereal time at Greenwhich\n */\nconst apparentSiderealTimeGreenwhich = function (T) {\n  const theta0 = meanSiderealTimeGreenwhich(T);\n  const epsilon = trueObliquityOfEcliptic(T);\n  const DeltaPsi = nutationInLongitude(T);\n  const theta = theta0 + DeltaPsi * auxMath.cosd(epsilon);\n  return auxMath.reduceAngle(theta);\n};\n\n/**\n * Calculates the mean sidereal time at Greenwhich (see AA p88 Eq12.4).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Mean sidereal time at Greenwhich\n */\nconst meanSiderealTimeGreenwhich = function (T) {\n  const JD2000 = T * 36525;\n  const theta0 = 280.46061837 + 360.98564736629 * JD2000 + 0.000387933 * T * T -\n                 T * T * T / 38710000;\n  return theta0;\n};\n\n/**\n * Calculates the true obliquity of the ecliptic (see AA p147).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} True obliquity of the ecliptic.\n */\nconst trueObliquityOfEcliptic = function (T) {\n  const epsilon0 = meanObliquityOfEcliptic(T);\n  const DeltaEpsilon = nutationInObliquity(T);\n  const epsilon = epsilon0 + DeltaEpsilon;\n  return epsilon;\n};\n\n/**\n * Calculates the mean obliquity of the ecliptic (see AA p147 Eq 22.3).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Mean obliquity of the ecliptic.\n */\nconst meanObliquityOfEcliptic = function (T) {\n  const U = T / 100;\n  const epsilon0 = auxMath.polynomial(U, constants.meanObliquityOfEcliptic);\n  return epsilon0;\n};\n\n/**\n * Calculates the apparent longitude of the sun (see AA p164).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Apparent longitude of the sun.\n */\nconst sunApparentLongitude = function (T) {\n  const Sol = sunTrueLongitude(T);\n  const Omega = moonAscendingNodeLongitude(T);\n  const lambda = Sol - 0.00569 - 0.00478 * auxMath.sind(Omega);\n  return lambda;\n};\n\n/**\n * Calculates the true longitude of the sun (see AA p164).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} True longitude of the sun.\n */\nconst sunTrueLongitude = function (T) {\n  const L0 = sunMeanLongitude(T);\n  const C = sunEquationOfCenter(T);\n  const Sol = L0 + C;\n  return Sol;\n};\n\n/**\n * Calculates the equation of center of the sun (see AA p164).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Equation of center of the sun.\n */\nconst sunEquationOfCenter = function (T) {\n  const M = sunMeanAnomaly(T);\n  const C = (1.914602 - 0.004817 * T - 0.000014 * T * T) * auxMath.sind(M) +\n            (0.019993 - 0.000101 * T) * auxMath.sind(2 * M) +\n            0.000290 * auxMath.sind(3 * M);\n  return C;\n};\n\n/**\n * Calculates the nutation in longitude of the sun (see AA p144ff).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Nutation in longitude of the sun.\n */\nconst nutationInLongitude = function (T) {\n  const D = moonMeanElongation(T);\n  const M = sunMeanAnomaly(T);\n  const MPrime = moonMeanAnomaly(T);\n  const F = moonArgumentOfLatitude(T);\n  const Omega = moonAscendingNodeLongitude(T);\n  let DeltaPsi = 0;\n  let sineArg;\n  for (let i = 0; i < 63; i++) {\n    sineArg = constants.nutations[i][0] * D +\n              constants.nutations[i][1] * M +\n              constants.nutations[i][2] * MPrime +\n              constants.nutations[i][3] * F +\n              constants.nutations[i][4] * Omega;\n    DeltaPsi += (constants.nutations[i][5] +\n                 constants.nutations[i][6] * T) * auxMath.sind(sineArg);\n  }\n  DeltaPsi /= 36000000;\n  return DeltaPsi;\n};\n\n/**\n * Calculates the nutation in obliquity of the sun (see AA p144ff).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Nutation in obliquity of the sun.\n */\nconst nutationInObliquity = function (T) {\n  const D = moonMeanElongation(T);\n  const M = sunMeanAnomaly(T);\n  const MPrime = moonMeanAnomaly(T);\n  const F = moonArgumentOfLatitude(T);\n  const Omega = moonAscendingNodeLongitude(T);\n  let DeltaEpsilon = 0;\n  let cosArg;\n  for (let i = 0; i < 63; i++) {\n    cosArg = constants.nutations[i][0] * D +\n             constants.nutations[i][1] * M +\n             constants.nutations[i][2] * MPrime +\n             constants.nutations[i][3] * F +\n             constants.nutations[i][4] * Omega;\n    DeltaEpsilon += (constants.nutations[i][7] +\n                     constants.nutations[i][8] * T) * auxMath.cosd(cosArg);\n  }\n  DeltaEpsilon /= 36000000;\n  return DeltaEpsilon;\n};\n\n/**\n * Calculates the argument of latitude of the moon (see AA p144).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Argument of latitude of the moon.\n */\nconst moonArgumentOfLatitude = function (T) {\n  const F = auxMath.polynomial(T, constants.moonArgumentOfLatitude);\n  return auxMath.reduceAngle(F);\n};\n\n/**\n * Calculates the longitude of the ascending node of the Moon's mean orbit on\n * the ecliptic, measured from the mean equinox of the datea (see AA p144).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Longitude of the asc. node of the moon's mean orbit.\n */\nconst moonAscendingNodeLongitude = function (T) {\n  const Omega = auxMath.polynomial(T, constants.moonAscendingNodeLongitude);\n  return auxMath.reduceAngle(Omega);\n};\n\n/**\n * Calculates the mean anomaly of the moon (see AA p144).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Mean anomaly of the moon.\n */\nconst moonMeanAnomaly = function (T) {\n  const MPrime = auxMath.polynomial(T, constants.moonMeanAnomaly);\n  return auxMath.reduceAngle(MPrime);\n};\n\n/**\n * Calculates the mean elongation of the moon from the sun (see AA p144).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Mean elongation of the moon from the sun.\n */\nconst moonMeanElongation = function (T) {\n  const D = auxMath.polynomial(T, constants.moonMeanElongation);\n  return auxMath.reduceAngle(D);\n};\n\n/**\n * Calculates the mean anomaly of the sun (see AA p144).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Mean anomaly of the sun.\n */\nconst sunMeanAnomaly = function (T) {\n  const M = auxMath.polynomial(T, constants.sunMeanAnomaly);\n  return auxMath.reduceAngle(M);\n};\n\n/**\n * Calculates the mean longitude of the sun referred to the mean equinox of the\n * date (see AA p163).\n * @param {number} T Fractional number of Julian centuries since\n *     2000-01-01T12:00:00Z.\n * @returns {number} Mean longitude of the sun referred to the mean equinox of\n *     the date.\n */\nconst sunMeanLongitude = function (T) {\n  const L0 = auxMath.polynomial(T, constants.sunMeanLongitude);\n  return auxMath.reduceAngle(L0);\n};\n\nexport {sunRiseSet, sunTransit, returnPNMS};\n","import * as moonPhases from './moonPhases.js';\nimport * as sunTimes from './sunTimes.js';\nimport * as timeConversions from './timeConversions.js';\n\nlet roundToNearestMinute = false;\nlet returnTimeForPNMS = false;\nlet dateFormatKeys = {'**': '‡', '--': '†'};\n\n/**\n * Sets options (roundToNearestMinute, returnTimeForPNMS, dateFormatKey) for the\n * module.\n * @param {object} options Options to be set.\n */\nconst options = function (options) {\n  if (typeof options.roundToNearestMinute === 'boolean') {\n    roundToNearestMinute = options.roundToNearestMinute;\n  }\n  if (typeof options.returnTimeForPNMS === 'boolean') {\n    returnTimeForPNMS = options.returnTimeForPNMS;\n  }\n  if (typeof options.dateFormatKeys === 'object') {\n    dateFormatKeys = options.dateFormatKeys;\n  }\n};\n\n/**\n * Uses the extra information encoded into the moment object for dates without\n * a sunrise or sunset if returnTimeForPNMS is true to mark the output string.\n * @param {moment} datetime Input datetime.\n * @param {string} formatString Valid moment format string.\n * @returns {string} Formatted string with marker appended.\n */\nconst formatCI = function (datetime, formatString) {\n  const customKey = datetime.creationData().input.slice(0, 2);\n  let datestring = datetime.format(formatString);\n  if (dateFormatKeys[customKey]) {\n    datestring += dateFormatKeys[customKey];\n  }\n  return datestring;\n};\n\n/**\n * Calculates sunrise on the provided date.\n * @param {moment} datetime Datetime for which sunrise is calculated. Should\n *     always contain a timezone or be in UTC, lone UTC offsets might lead to\n *     unexpected behaviour.\n * @param {number} phi Latitude of target location.\n * @param {number} L longitude of target location.\n * @returns {(moment|string)} Time of sunrise or a string indicating that the\n *     location experiences midnight sun ('MS') or polar night ('PN') on that\n *     date (unless returnTimeForPNMS is true).\n */\nconst sunrise = function (datetime, phi, L) {\n  let sunrise;\n  try {\n    sunrise = sunTimes.sunRiseSet(datetime, phi, L, 'RISE');\n  } catch (err) {\n    return sunTimes.returnPNMS(err, datetime, 6);\n  }\n  return sunrise;\n};\n\n/**\n * Calculates sunset on the provided date.\n * @param {moment} datetime Datetime for which sunset is calculated. Should\n *     always contain a timezone or be in UTC, lone UTC offsets might lead to\n *     unexpected behaviour.\n * @param {number} phi Latitude of target location.\n * @param {number} L longitude of target location.\n * @returns {(moment|string)} Time of sunset or a string indicating that the\n *     location experiences midnight sun ('MS') or polar night ('PN') on that\n *     date (unless returnTimeForPNMS is true).\n */\nconst sunset = function (datetime, phi, L) {\n  let sunset;\n  try {\n    sunset = sunTimes.sunRiseSet(datetime, phi, L, 'SET');\n  } catch (err) {\n    return sunTimes.returnPNMS(err, datetime, 18);\n  }\n  return sunset;\n};\n\n/**\n * Calculates civil dawn (sun 6° below horizon) on the provided date.\n * @param {moment} datetime Datetime for which civil dawn is calculated. Should\n *     always contain a timezone or be in UTC, lone UTC offsets might lead to\n *     unexpected behaviour.\n * @param {number} phi Latitude of target location.\n * @param {number} L longitude of target location.\n * @returns {(moment|string)} Time of civil dawn or a string ('NCD') indicating\n *     that the location does not experience civil dawn on that date (unless\n *     returnTimeForPNMS is true).\n */\nconst civilDawn = function (datetime, phi, L) {\n  let civilDawn;\n  try {\n    civilDawn = sunTimes.sunRiseSet(datetime, phi, L, 'RISE', 6);\n  } catch (err) {\n    return sunTimes.returnPNMS(err, datetime, 5, 30);\n  }\n  return civilDawn;\n};\n\n/**\n * Calculates civil dusk (sun 6° below horizon) on the provided date.\n * @param {moment} datetime Datetime for which civil dusk is calculated. Should\n *     always contain a timezone or be in UTC, lone UTC offsets might lead to\n *     unexpected behaviour.\n * @param {number} phi Latitude of target location.\n * @param {number} L longitude of target location.\n * @returns {(moment|string)} Time of civil dusk or a string ('NCD') indicating\n *     that the location does not experience civil dusk on that date (unless\n *     returnTimeForPNMS is true).\n */\nconst civilDusk = function (datetime, phi, L) {\n  let civilDusk;\n  try {\n    civilDusk = sunTimes.sunRiseSet(datetime, phi, L, 'SET', 6);\n  } catch (err) {\n    return sunTimes.returnPNMS(err, datetime, 18, 30);\n  }\n  return civilDusk;\n};\n\n/**\n * Calculates nautical dawn (sun 12° below horizon) on the provided date.\n * @param {moment} datetime Datetime for which nautical dawn is calculated.\n *     Should always contain a timezone or be in UTC, lone UTC offsets might\n *     lead to unexpected behaviour.\n * @param {number} phi Latitude of target location.\n * @param {number} L longitude of target location.\n * @returns {(moment|string)} Time of nautical dawn or a string ('NND')\n *     indicating that the location does not experience nautical dawn on that\n *     date (unless returnTimeForPNMS is true).\n */\nconst nauticalDawn = function (datetime, phi, L) {\n  let nauticalDawn;\n  try {\n    nauticalDawn = sunTimes.sunRiseSet(datetime, phi, L, 'RISE', 12);\n  } catch (err) {\n    return sunTimes.returnPNMS(err, datetime, 5);\n  }\n  return nauticalDawn;\n};\n\n/**\n * Calculates nautical dusk (sun 12° below horizon) on the provided date.\n * @param {moment} datetime Datetime for which nautical dusk is calculated.\n *     Should always contain a timezone or be in UTC, lone UTC offsets might\n *     lead to unexpected behaviour.\n * @param {number} phi Latitude of target location.\n * @param {number} L longitude of target location.\n * @returns {(moment|string)} Time of nautical dusk or a string ('NND')\n *     indicating that the location does not experience nautical dusk on that\n *     date (unless returnTimeForPNMS is true).\n */\nconst nauticalDusk = function (datetime, phi, L) {\n  let nauticalDusk;\n  try {\n    nauticalDusk = sunTimes.sunRiseSet(datetime, phi, L, 'SET', 12);\n  } catch (err) {\n    return sunTimes.returnPNMS(err, datetime, 19);\n  }\n  return nauticalDusk;\n};\n\n/**\n * Calculates astronomical dawn (sun 18° below horizon) on the provided date.\n * @param {moment} datetime Datetime for which astronomical dawn is calculated.\n *     Should always contain a timezone or be in UTC, lone UTC offsets might\n *     lead to unexpected behaviour.\n * @param {number} phi Latitude of target location.\n * @param {number} L longitude of target location.\n * @returns {(moment|string)} Time of astronomical dawn or a string ('NAD')\n *     indicating that the location does not experience astronomical dawn on\n *     that date (unless returnTimeForPNMS is true).\n */\nconst astronomicalDawn = function (datetime, phi, L) {\n  let astronomicalDawn;\n  try {\n    astronomicalDawn = sunTimes.sunRiseSet(datetime, phi, L, 'RISE', 18);\n  } catch (err) {\n    return sunTimes.returnPNMS(err, datetime, 4, 30);\n  }\n  return astronomicalDawn;\n};\n\n/**\n * Calculates astronomical dusk (sun 18° below horizon) on the provided date.\n * @param {moment} datetime Datetime for which astronomical dusk is calculated.\n *     Should always contain a timezone or be in UTC, lone UTC offsets might\n *     lead to unexpected behaviour.\n * @param {number} phi Latitude of target location.\n * @param {number} L longitude of target location.\n * @returns {(moment|string)} Time of astronomical dusk or a string ('NAD')\n *     indicating that the location does not experience astronomical dusk on\n *     that date (unless returnTimeForPNMS is true).\n */\nconst astronomicalDusk = function (datetime, phi, L) {\n  let astronomicalDusk;\n  try {\n    astronomicalDusk = sunTimes.sunRiseSet(datetime, phi, L, 'SET', 18);\n  } catch (err) {\n    return sunTimes.returnPNMS(err, datetime, 19, 30);\n  }\n  return astronomicalDusk;\n};\n\n/**\n * Calculates solar noon on the provided date.\n * @param {moment} datetime Datetime for which solar noon is calculated. Should\n *     always contain a timezone or be in UTC, lone UTC offsets might lead to\n *     unexpected behaviour.\n * @param {number} L longitude of target location.\n * @returns {moment} Time of solar noon at the given longitude.\n */\nconst solarNoon = function (datetime, L) {\n  const transit = sunTimes.sunTransit(datetime, L);\n  return transit;\n};\n\n/**\n * Calculates all moons of the given phase that occur within the given\n * Gregorian calendar year.\n * @param {int} year Year for which moon phases should be calculated.\n * @param {int} phase 0 -> new moon, 1 -> first quarter,\n *                    2 -> full moon, 3 -> last quarter.\n * @param {string} timezone Optional: IANA timezone string.\n * @returns {array} Array of moment objects for moons of the given phase.\n */\nconst yearMoonPhases = function (year, phase, timezone) {\n  const yearBegin = moment([year]);\n  const yearEnd = moment([year + 1]);\n  // this will give us k for the first new moon of the year or earlier\n  let k = Math.floor(timeConversions.approxK(yearBegin)) - 1;\n  // taking 15 events will make sure we catch every event in the year\n  const phaseTimes = [];\n  let JDE;\n  let moonDatetime;\n  let DeltaT;\n  for (let i = 0; i < 15; i++) {\n    JDE = moonPhases.truePhase(k, phase);\n    // we pretend it's JD and not JDE\n    moonDatetime = timeConversions.JDToDatetime(JDE);\n    // now use that to calculate deltaT\n    DeltaT = timeConversions.DeltaT(moonDatetime);\n    if (DeltaT > 0) {\n      moonDatetime.subtract(Math.abs(DeltaT), 'seconds');\n    } else {\n      moonDatetime.add(Math.abs(DeltaT), 'seconds');\n    }\n    if (roundToNearestMinute) {\n      moonDatetime.add(30, 'seconds');\n      moonDatetime.second(0);\n    }\n    if (typeof timezone === 'undefined') {\n      timezone = 'UTC';\n    }\n    moonDatetime.tz(timezone);\n    if ((moonDatetime.isAfter(yearBegin)) && (moonDatetime.isBefore(yearEnd))) {\n      phaseTimes.push(moonDatetime);\n    }\n    k++;\n  }\n  return phaseTimes;\n};\n\nexport {options, formatCI, sunrise, sunset, civilDawn, civilDusk, nauticalDawn,\n  nauticalDusk, astronomicalDawn, astronomicalDusk, solarNoon, yearMoonPhases,\n  roundToNearestMinute, returnTimeForPNMS};\n"],"names":["deg2rad","deg","rad2deg","rad","sind","Math","sin","cosd","cos","reduceAngle","angle","floor","polynomial","variable","coeffs","varPower","sum","numCoeffs","length","i","interpolateFromThree","y1","y2","y3","n","normalize","a","b","JDToDatetime","JD","Z","F","A","alpha","B","C","D","E","fracDay","day","hours","minutes","seconds","month","year","datetime","moment","tz","date","hour","minute","second","datetimeToT","JDToT","Y","M","gregorianCutoff","isAfter","datetimeToJD","DeltaT","u","t","y","truePhase","k","phase","T","timeConversions","eccentricityCorrection","JDE","meanPhase","sunMeanAnomaly","MPrime","moonMeanAnomaly","moonArgumentOfLatitude","Omega","moonAscendingNodeLongitude","planetaryArguments","DeltaJDE","newMoonFullMoonCorrections","quarterCorrections","commonCorrections","auxMath","W","sunMeanLongitude","meanObliquityOfEcliptic","moonMeanElongation","nutations","sunRiseSet","phi","L","flag","m","offset","timezone","suntime","Theta0","apparentSiderealTimeGreenwhich","TD","sunApparentRightAscension","delta","sunApparentDeclination","H0","approxLocalHourAngle","m0","normalizeM","utcOffset","counter","DeltaM","abs","sunRiseSetCorrection","add","subtract","roundToNearestMinute","returnPNMS","returnDate","returnTimeForPNMS","isDST","cosH0","special","acos","localM","sunTransitCorrection","theta0","interpolatedRa","localHourAngle","interpolatedDec","H","altitude","asin","alpha1","alpha2","alpha3","delta1","delta2","delta3","epsilon","trueObliquityOfEcliptic","lambda","sunApparentLongitude","atan2","meanSiderealTimeGreenwhich","theta","nutationInLongitude","nutationInObliquity","constants","Sol","sunTrueLongitude","sunEquationOfCenter","sineArg","DeltaPsi","cosArg","DeltaEpsilon","L0","dateFormatKeys","astronomicalDawn","sunTimes","err","astronomicalDusk","civilDawn","civilDusk","formatString","customKey","creationData","input","slice","datestring","format","nauticalDawn","nauticalDusk","options","_typeof","transit","sunrise","sunset","moonDatetime","yearBegin","yearEnd","phaseTimes","moonPhases","isBefore","push"],"mappings":"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"}